<!--- TEST_NAME BasicsGuideTest -->

[//]: # (title: Coroutines basics)

В этом разделе рассматриваются основные концепции корутин.

## Ваша первая корутина

_Корутина_ - это экземпляр приостанавливаемых вычислений. Концептуально она похожа на поток выполнения (thread),
в том смысле, что принимает блок кода для выполнения, работающий параллельно с остальным кодом.
Однако, корутина не привязана к какому-либо конкретному потоку. Она может приостановить свое выполнение в одном потоке и возобновить в другом.

Корутины можно рассматривать как легковесные потоки, но существует несколько важных отличий,
которые делают их использование в реальной жизни сильно отличным от потоков.

Запустите следующий код, чтобы создать свою первую работающую корутину:

```kotlin
import kotlinx.coroutines.*

//sampleStart
fun main() = runBlocking { // this: CoroutineScope
    launch { // запустить новую корутину и продолжить
        delay(1000L) // неблокирующая задержка на 1 секунду (единица времени по умолчанию — мс)
        println("World!") // печать после задержки
    }
    println("Hello") // основная корутина продолжается, в то время как предыдущая задерживается
}
//sampleEnd
```

Вы увидите следующий результат:

```text
Hello
World!
```

<!--- TEST -->

Давайте разберем, что делает этот код. 

[launch] - это _билдер корутин_ (coroutine builder). Он запускает новую корутину параллельно с остальным кодом,
который продолжает работать независимо. Вот почему `Hello` было выведено первым.

[delay] - это особая _функция приостановки_ (suspending function). Она _приостанавливает_ выполнение корутины на определенное время.
Приостановка корутины _не блокирует_ базовый поток выполнения, но позволяет другим корутинам запускаться и использовать базовый поток для своего кода.

[runBlocking] - это также _строитель корутин_, который соединяет не корутинный мир обычной функции `fun main()` и код с корутинами внутри
фигурных скобок `runBlocking { ... }`. Это подчеркивается в среде разработки (IDE) `this: CoroutineScope`, который отображается
сразу после открывающей фигурной скобки `runBlocking`.

Если вы удалите или забудете использовать `runBlocking` в этом коде, то вы получите ошибку на вызове [launch],
так как `launch` объявлен только внутри [CoroutineScope].

```Plain Text
Unresolved reference: launch
```

Название `runBlocking` означает, что поток, который запускает его (в данном случае — главный поток),
становится _заблокированным_ на время вызова, пока все корутины внутри `runBlocking { ... }` не завершат своё выполнение.
Вы часто увидите использование `runBlocking` именно таким образом на самом верхнем уровне приложения и достаточно редко внутри реального кода,
так как потоки являются дорогостоящими ресурсами, и блокирование их неэффективно и часто не желательно.

### Структурированный параллелизм

Корутины следуют принципу **структурированного параллелизма**, что означает, что новые корутины могут быть запущены
только в определенном [CoroutineScope], который ограничивает время жизни корутины. Вышеупомянутый пример показывает,
что [runBlocking] устанавливает соответствующую область видимости, и поэтому предыдущий пример ждет,
пока через секунду будет напечатано `World!`, а затем завершается.

В реальном приложении вы будете запускать множество корутин. Структурированный параллелизм гарантирует,
что они не потеряются и не будут утекать. Внешняя область видимости не может завершиться, пока все дочерние
корутины не завершат свою работу. Структурированный параллелизм также гарантирует, что любые ошибки в коде
будут правильно отображаться и никогда не будут потеряны.

## Рефакторинг извлечения функции

> Рефакторинг извлечения функции (Extract Function Refactoring) - это процесс переноса фрагмента кода из существующей
> функции в новую функцию, чтобы улучшить структуру и понимание кода. Этот рефакторинг позволяет разбить сложные процедуры
> на более мелкие и простые функции, улучшая тем самым читабельность, тестируемость и переиспользуемость кода.

Давайте извлечем блок кода из launch `{ ... }` в отдельную функцию. При выполнении рефакторинга "Извлечение функции" на этом коде
вы получите новую функцию с модификатором `suspend`. Это ваша первая _функция приостановки_ (suspend function). Функции приостановки могут использоваться
внутри корутин так же, как и обычные функции, но их дополнительной особенностью является то, что они могут, в свою очередь,
использовать другие функции приостановки (как `delay` в этом примере), чтобы _приостановить_ выполнение корутина.

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking { // this: CoroutineScope
    launch { doWorld() }
    println("Hello")
}

// Ваша первая suspend функция
suspend fun doWorld() {
    delay(1000L)
    println("World!")
}
```

<!--- TEST
Hello
World!
-->

## Билдер Scope'ов

В дополнение к контексту корутины, предоставляемому различными строителями, можно объявить свой собственный контекст,
используя билдер [coroutineScope][_coroutineScope]. Он создает контекст корутины и не завершает его, пока все запущенные потомки не завершатся.

Методы [runBlocking] и [coroutineScope][_coroutineScope] могут выглядеть похожими, потому что оба ждут завершения своего тела и всех его потомков.
Основное отличие заключается в том, что метод [runBlocking] _блокирует_ текущий поток ожидания, в то время как [coroutineScope][_coroutineScope] просто
приостанавливает выполнение, освобождая базовый поток для других использований. Из-за этого различия [runBlocking] является обычной функцией,
а [coroutineScope][_coroutineScope] - функцией приостановки.

Вы можете использовать `coroutineScope` из любой suspend функции.
Например, вы можете переместить параллельную печать `Hello` и `World` в функцию `suspend fun doWorld()`:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    doWorld()
}

suspend fun doWorld() = coroutineScope {  // this: CoroutineScope
    launch {
        delay(1000L)
        println("World!")
    }
    println("Hello")
}
```

Этот код также печатает:

```text
Hello
World!
```

<!--- TEST -->

## Билдер Scope'ов и параллелизм

Строитель [coroutineScope] может быть использован внутри любой suspend функции для выполнения нескольких параллельных операций.
Давайте запустим две параллельные корутины внутри функции приостановки `doWorld`:

```kotlin
import kotlinx.coroutines.*

// Последовательно выполняет doWorld, за которым следует "Готово"
fun main() = runBlocking {
    doWorld()
    println("Done")
}

// Одновременно выполняются обе секции
suspend fun doWorld() = coroutineScope { // this: CoroutineScope
    launch {
        delay(2000L)
        println("World 2")
    }
    launch {
        delay(1000L)
        println("World 1")
    }
    println("Hello")
}
```

Оба блока кода внутри блоков `launch { ... }` выполняются _одновременно_, с выводом `World 1` первым, через секунду после запуска,
а затем выводится `World 2` через две секунды после запуска. [coroutineScope][_coroutineScope] в функции `doWorld` завершается только
после завершения обоих корутин, так что `doWorld` возвращает управление и позволяет выводить строку `Done` только после этого:

```text
Hello
World 1
World 2
Done
```

<!--- TEST -->

## Явная задача (An explicit job)

Корутин-билдер [launch] возвращает объект [Job], который представляет собой ссылку на запущенную корутину и
может быть использован для явного ожидания его завершения. Например, вы можете дождаться завершения дочерней корутины и затем вывести строку "Done":

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    val job = launch { // запускаем новую корутину и сохраняем ссылку на ее Job
        delay(1000L)
        println("World!")
    }
    println("Hello")
    job.join() // ждём пока дочерняя корутина завершится
    println("Done") 
}
```

Этот код производит: 

```text
Hello
World!
Done
```

<!--- TEST -->

## Корутины легковесные (light-weight)

Корутины используют меньше ресурсов, чем потоки JVM. Код, который исчерпывает доступную память JVM при использовании потоков,
может быть выполнен с использованием корутин без превышения лимита ресурсов. Например, следующий код запускает 100000 отдельных
корутин, каждая из которых ждет 5 секунд, затем выводит точку (`.`) и потребляет очень мало памяти:

```kotlin
import kotlinx.coroutines.*

fun main() = runBlocking {
    repeat(100_000) { // запуск множества корутин
        launch {
            delay(5000L)
            print(".")
        }
    }
}
```

> Хоть корутины и потребляют меньше памяти, чем потоки JVM, 
> этот пример исчерпает кучу памяти в песочнице; не запускайте его.

<!--- TEST lines.size == 1 && lines[0] == ".".repeat(100_000) -->

Если вы напишете ту же программу, используя потоки (удалите `runBlocking`, 
замените `launch` на `thread` и замените `delay` на `Thread.sleep`), то вероятнее всего,
она потребует слишком много памяти и выбросит ошибку нехватки памяти (out-of-memory).

<!--- MODULE kotlinx-coroutines-core -->
<!--- INDEX kotlinx.coroutines -->

[launch]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html
[delay]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html
[runBlocking]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html
[CoroutineScope]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/index.html
[_coroutineScope]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html
[Job]: https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html

<!--- END -->
